= Javascript Framework
include::../variables.adoc[]
:toc: right
:imagesdir: images

Enonic XP extensively uses server-side JavaScript for application development.
Our goal is to enable developer of any language - PHP, .net, Java, Python, etc to quickly grasp and be productive with Enonic XP.

Here are some highlights:

* *Runs on the JVM* using the Nashorn engine. Future releases of XP will likely use GraalVM
* *Javascripts are compiled and cached* on first request, for optimal performance
* *Multithreaded* request-response approach - simplifying software development and utilization of modern multi-core hardware
* *Based on the http://wiki.commonjs.org/wiki/Modules/1.1[CommonJS module specification]* like RequireJS
* *Invoke Java* directly from your scripts - quickly accessing powerful Java libraries
* *Full HTTP support* including Websockets

== HTTP Controllers

JavaScript controllers are the core concept of the Enonic XP framework.
Every javascript file is considered a controller, and the controllers are initiated through their exports.

For instance, every application may have an <<Application Controller>> that is invoked based on application life-cycle events.

JavaScript http controllers simply export functions matching the desired HTTP Method it implements.
As such, any controller must explicitly declare one or more "exports" in order to handle requests:
``get``, ``post``, ``delete`` are examples of such methods.

A controller can also export a special function ``all`` which will handle any HTTP method, unless there is a more specific handler available.

The appropriate function will automatically be invoked for every request sent to the controller.

Example usage
[source,javascript]
----
include::code/controller-1.js[]
----

A handler function receives a parameter with a ``request`` object, and returns a ``response`` object.

[source,javascript]
----
include::code/controller-2.js[]
----

== Global objects and functions

The following global functions and objects are available in the Enonic XP framework.

=== App

The globally available ``app`` object holds information about the contextual app. It has the following properties:

app.name:: The name of the application.

app.version:: Version of the application.

app.config:: Values from the application's configuration file. This can be set using ``$XP_HOME/config/<app.name>.cfg``. Every time the configuration is changed the app is restarted.

Examples:

[source,javascript]
----
include::code/app.js[]
----


=== Log

This globally available ``log`` object holds the logging methods. It's one method for each log
level and takes the same number of parameters.

[source,javascript]
  log.debug(message, [args]) <!--1--> <!--2-->

<1> *string message* Message to log as a debug-level message.
<2> *array args* Optional arguments used in message format.

[source,javascript]
  log.info(message, [args]) <!--1--> <!--2-->

<1> *string message* Message to log as a info-level message.
<2> *array args* Optional arguments used in message format.

[source,javascript]
  log.warning(message, [args]) <!--1--> <!--2-->

<1> *string message* Message to log as a warning-level message.
<2> *array args* Optional arguments used in message format.

[source,javascript]
  log.error(message, [args]) <!--1--> <!--2-->

<1> *string message* Message to log as a error-level message.
<2> *array args* Optional arguments used in message format.

Examples:

[source,javascript]
----
include::code/log.js[]
----


=== Resolve()

This globally available function resolves a fully qualified path to a local resource based
on the current location. It does not check if a resource exists at the specified path.
This function supports both relative (with dot-references) and absolute paths.

[source,javascript]
  resolve(path) <!--1--> <!--2-->

<1> *string path* Path to resolve using current location.
<2> *returns* the fully qualified resource path of the location.


Examples:

[source,javascript]
----
include::code/resolve.js[]
----

=== Require()

This globally available function will load a JavaScript file and return the exports as objects.
The function implements parts of the `CommonJS Modules Specification`_.

[source,javascript]
  require(path) <!--1--> <!--2-->

<1> *string path* Path to the JavaScript to load.
<2> *returns* The loaded JavaScript object exports.


Examples:

[source,javascript]
----
include::code/require.js[]
----

If the path is relative then it will start looking for the file from the local directory.
If the file is not found there, it will start scanning in parent directories that have a /lib folder until it reaches the resources/ folder.
The file extension .js is not required.


=== Exports

The globally available ``exports`` keyword is used to expose functionality from a given JavaScript file (controllers, libraries etc).
This is part of the require.js spec.

Simply use the ``exports`` keyword to expose functionality from any JavaScript file.

=== Double underscore __

The double underscore is available in any server-side JavaScript code and is used for wrapping Java objects in a JavaScript object. Read
more about <<Java bridge>>.


== Application Controller

When application lifecycle events like start or stop occurs, it can trigger a special controller. By adding a ``main.js`` file to the root of your application
(``/src/main/resources/``) this file is executed when the application starts.
Use this for instance to add initialization code or event listeners to your application.

Simple example:

[source,javascript]
----
include::code/main-1.js[]
----

Running code on stop:

[source,javascript]
----
include::code/main-2.js[]
----


== HTTP Request

The following object is passed along with every HTTP request. The object is similar to many traditional request objects, except for two special properties:
mode and branch. These properties are specific to the XP Portal, automatically indicating the contextual branch and rendering mode.

The ``request`` object represents the HTTP request and current context for the
controller.

[source,json]
----
{
  "method": "GET", <!--1-->
  "scheme": "http", <!--2-->
  "host": "enonic.com", <!--3-->
  "port": "80", <!--4-->
  "path": "/my/page", <!--5-->
  "url": "http://enonic.com/my/page?debug=true", <!--6-->
  "remoteAddress": "10.0.0.1", <!--7-->
  "mode": "edit", <!--8-->
  "branch": "master", <!--9-->
  "body": null <!--10-->
  "params": { <!--11-->
    "debug": "true"
  },
  "headers": { <!--12-->
    "Language": "en",
    "Cookies": "mycookie=123; other=abc;"
  },
  "cookies": { <!--13-->
    "mycookie": "123",
    "other": "abc"
  }
}
----

<1> HTTP method of the request
<2> Scheme used to make this request i.e. "http" / "https"
<3> Host name of the server to which the request was sent.
<4> Port of the server to which the request was sent.
<5> Path of the request
<6> URL of the request.
<7> IP address of the client that sent the request. If the X-Forwarded-For footnote:[http://en.wikipedia.org/wiki/X-Forwarded-For] header is set, its value will override the client IP.
<8> Rendering mode (used in site context) one of: ``inline``, ``edit``, ``preview``, ``live``.
<9> Contextual repository branch (used in site context), one of: ``draft``, ``master``.
<10> Optional string value
<11> Name/value pairs of the query/form parameters from the request.
<12> Name/value pairs of the HTTP request headers.
<13> Name/value pairs of the HTTP request cookies.

== HTTP Response

The ``response`` object is the value returned by an HTTP controller - as a response to an :ref:`http_request`.

[source,json]
----
{
  "status": 200, <!--1-->
  "body": "Hello World", <!--2-->
  "contentType": "text/plain", <!--3-->
  "headers": {  <!--4-->
      "key": "value"
  },
  "cookies": {},  <!--5-->
  "redirect": "/another/page",  <!--6-->
  "pageContributions": {},  <!--7-->
  "postProcess": true,  <!--8-->
  "applyFilters": true  <!--9-->
}
----

<1> HTTP response status code (default is ``200``).
<2> HTTP message body of the response that can either be a string or a JavaScript object.
<3> MIME type of the body (defaults to ``text/plain; charset=utf-8``).
<4> Name/value pairs with the HTTP headers to be added to the response.
<5> HTTP cookies to be added to the response. Will be described in a later section.
<6> URI to redirect to. If specified, the value will be set in the "Location" header and the status will be set to 303.
<7> A special filter available for sites and page components allowing page components to contribute html to the main page markup. See :ref:`page_contributions`
<8> Post-processing is a special filter for sites and pages, if enabled it will reprosess a page looking for page contributions and rendering components in a page. (See also :ref:`page_contributions`) (default is ``true``). Set to false if you want to speed up page rendering in cases where there are no regions or page components.
<9> Whether or not to execute the filters after rendering. Set to ``false`` to skip execution of filters. (See also :ref:`response_filters`) (default is ``true``).

== HTTP Cookies

There are two ways that Http Cookie values can be set in responses (see examples).

Here's an example of how the cookies are set:

[source,javascript]
----
return {
    status: 200,
    body: "Hello World",
    cookies: {
        "plain": "value", <!--1-->
        "complex": { <!--2-->
            value: "value", <!--3-->
            path: "/valid/path", <!--4-->
            domain: "enonic.com", <!--5-->
            comment: "Some cookie comments", <!--6-->
            maxAge: 2000, <!--7-->
            secure: false, <!--8-->
            httpOnly: false <!--9-->
        }
    }
};
----

<1> If the value is a string then the cookie is created using default settings.
<2> If the value is an object, it will try to apply the settings.
<3> Value (required) The value to store in the cookie. This example will create a cookie looking like this ``complex: value``.
<4> The paths on the site where this cookie should be available from (and all containing paths). Defaults to ``empty``
<5> Add additional sites that should be able to read the cookie. Defaults to ``empty`` (Only the server that creates the cookie can read it.)
<6> A comment describing the cookie. Default to ``null`.
<7> Number of **seconds** before the browser is allowed to delete the cookie. Defaults to ``-1`` (The cookie will live until the browser is shut down.)
<8> Control if the cookie should only be accepted to be created and read over https and similar secure protocols. Defaults to ``false``
<9> Control if the cookie is available for scripts or not. If `true`, only the serverside code can read the cookie. Defaults to ``false`` (Also client-side scripts can read the cookie.)

== Websockets

Websocket support allows a service to act as a websocket channel that
you can connect to from a web-browser.

A ``get`` method must be implemented to handle initialization
of the websocket.

[source,javascript]
----
include::code/websockets-1.js[]
----

A websocket event handler named ``webSocketEvent`` is required. It will be called for every websocket event from a client. See example below.

[source,javascript]
----
include::code/websockets-2.js[]
----

Below is an example of a simple chat. A library called ``lib-websocket`` has functions for sending messages back and adding/removing clients
in groups. Adding to groups allows for multicast message sending.

[source,javascript]
----
include::code/websockets-3.js[]
----

== Java bridge

In Enonic XP, there is a standard object named ``__`` (double underscore), accessible from any serverside JavaScript code, which provides
a way to wrap Java objects in a JavaScript object.  The ``__`` object has functions that allow JavaScript to communicate with Java
classes. The ``newBean`` function will wrap the Java object named in the parameter, for instance:

[source,javascript]
----
var bean = __.newBean('com.enonic.xp.lib.io.IOHandlerBean');
----

This line is from the ``lib-io`` library, which is a good example of how this is used. In the Java ``IOHandlerBean`` class, there are several
methods, like the ``readLines`` method:

[source,java]
----
public List<String> readLines( final Object value )
  throws Exception
    {
      final CharSource source = toCharSource( value );
      return source.readLines();
    }
----

This method is now accessible as a function on the JavaScript ``bean`` and may be invoked from JavaScript, like this:

[source,javascript]
----
exports.readLines = function (stream) {
  return __.toNativeObject(bean.readLines(stream));
  };
----

This results in a global JavaScript function ``readLines``. This example also shows the use of the ``toNativeObject`` method, which in
this case, converts a Java String array to a JSON object.
TODO: LINKFIX: Also check out the http://repo.enonic.com/public/com/enonic/xp/docs/{release}/docs-{release}-libdoc.zip!/\_\_.html[reference documentation for the ``__`` object].
