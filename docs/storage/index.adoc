= NoSQL Data Store
:toc: right
:imagesdir: images

Enonic XP ships with a unique and powerful document-oriented data storage, built on top of the popular search engine "Elasticsearch".

== Background

Years of experience has taught us that traditional approaches to data storage (read SQL) are unsuited for modern cloud-based applications.
A key goal of Enonic XP was to deliver a complete stack - reducing the dependencies for complex infrastructure.

We evaluated many different technologies and found inspiration in everything from Git, File systems, Object storage, Java Content Repository, and Elasticsearch.
However, we were unable to find any single solution that was sufficiently simple and supported our requirements - so we decided to build our own technology.

The result is the Enonic Data Repository.

== Features

The XP Repository enables you to store, index, query and access data of virtually any kind. Fast and efficiently.
Below is a highlight of the capabilities provided:

* Create any number of <<Repositories>> within a single deployment of XP
* Store and index documents aka <<Nodes>>, no schemas required
* Nodes contain key-value entries called <<Properties>>
* A property may hold a single value, or an array of values
* Values have specific <<Value Types>>, for instance String or GeoPoint
* Store entire files and byte arrays within a single property
* Build hierarchical structures of properties within a single node
* Nodes can be stored hierachically, for building tree structures
* Query your data using the <<Enonic Query Language>>
* Use <<Aggregations>> to get powerful statistics on your data
* Node-level <<Versioning>> lets you do rollbacks and store important events
* <<Access Control>> down to a single Node
* Git inspired <<Branches>> enable you to stage and promote your data
* Fully <<Schema-less>> approach lets you keep the domain model in your code
* <<Editors>> eliminate cumbersome statements
* <<Snapshot>> feature to rollback entire system or per repository
* <<Export and Import>> nodes in a human readable format
* <<Dump and Load>> your entire system to include all versions and data

== Repositories

Repositories are the fundamental concept that enables you to create and store data in silos.
You may create any number of repositories within a single instance of Enonic XP.

Each repository must have a name.
Best practice is to name or prefix the repository according to your application. i.e. a good repository name might be: com.company.myapp

Data stored in a repository will typically belong to a common domain. Fetches and searches are typically executed against
a single repository, so it makes sense to keep data from different domains separated in different repositories.

image::sub-repos.png[]

=== Standard repositories

Out of the box, Enonic XP ships with two built-in repositories:

* ``system-repo``: The core repository. Here, users and groups, references to other repositories, installed application etc are stored.
* ``cms-repo`` : Content domain data, this is the data managed in the Content Studio app.


=== Managing repositories

An API for managing repositories is available, but we also recommend checking out https://market.enonic.com/vendors/glenn-ricaud/data-toolbox.
When creating or deleting a repository, underlying storage- and search-indexes will be created. Metadata regarding these repositories are stored in the ``system-repo``.

=== Persistence
The XP repository essentially deals with data and metadata. Data and selected metadata structures are persisted as files. Other metadata and search indexes are stored and distributed with Elasticsearch, which is embedded
Files are stored in so-called BlobStores. BlobStores are organized per repository, and by type, which makes it easy to identify which files belong to what repository.

For clustered deployments, Enonic XP currently relies on access to a shared file system.

== Nodes

Each entry in a repository is called a Node.

A node essentially consist of:
* one or more <<Properties>>
* An optional <<Index Configuration>>
* Optional <<Access Control>> definition

When nodes are created in a repository, the following happens:

* A unique identifier is created for the node (unless defined through import)
* A unique version identifier for the node is created
* The data is stored in a <<Blobstore>> of type node
* The node and it's specific version is then added to a <<Branch>>.  This entry keeps track of the tree-structure and other metadata for the specific node-version.

=== Properties
Properties represent placement of data in a node following the key-value pattern.

The key must be a unique name within the node, and the value must have a specific <<ValueType>>, such as ``String``, or ``GeoPoint``.
The valueType is used to index the property correctly, and provide basic validation.

Examples of properties might be:


[source,properties]
----
mytext = "a string"
mynumber = 1
----

Some characters are illegal in a property key. Here's a list of illegal characters:

* ``_`` is system reserved prefix
* ``.`` is the path separator.
* ``[`` and ``]`` are array index indicators.


Properties may also be nested, making the key a path.
Elements in the path are separated by ``.`` (dot).

Here's an example of properties with arrays and nested properties.

[source,properties]
----
first-name = "Thomas"
cities = ["Oslo", "San Francisco"]
city.location = geoPoint('37.785146,-122.39758')
person.age = 39
person.birth-date = localDate("1975-17-10")
----

In the example above, the property person is of the special <<ValueType>> ``Set``.


=== ValueTypes

Every property to be stored in a node must have a value type.
The value type enables the system to interpret and handle each piece of data specially - applying to both validation and indexing.

Below is a complete list of all supported value-types.

[cols="1,1,2"]
|===
|Value Type |Example |Comment

|String
|``My String``
|String of characters within UTF charset

|BinaryReference
|``a-binary-reference``
|Handle for accessing a binary

|Boolean
|``true``
|A value representing ``true`` or ``false``

|Double
|``11.5``
|Double-precision 64-bit IEEE 754 floating point.

|GeoPoint
|``59.9090442,10.7423389``
|Represents a geographical point, given in latitude and longitude.

|Instant
|``2015-03-16T10:00:02Z``
|A single point on the time-line.

|LocalTime
|``10:00:03``
|A time representation without timezone

|LocalDateTime
|``2015-03-16T10:00:02``
|A date-time representation without timezone.


|Long
|``1234``
|64-bit two's complement integer.

|Reference
|``0b7f7720-6ab1-4a37-8edc-731b7e4f439e``
|Holds a reference to other nodes in the same repository.

|Set
|
|Holds properties as it's value - sets are not indexed

|XML
|<some>xml</some>
|Any valid XML
|===


== System Properties

To reduce complexity, explicit namespaces are not used.
Thus, in order to separate system properties from user defined properties, we have reserved ``_`` as a starting character for system defined properties.

Below are the system properties explained.

_childOrder::
Default ordering of children when doing find children if no other order expression is given

_id::
Holds the id of the node, typically generated automatically in the form of a UUID.

_indexConfig::
Specification on how to index properties

_manualOrderValue::
Numeric order value used for the builtin manual ordering

_name::
Holds the name of the node. The name must be unique within its scope (all nodes with same parent).

_nodeType::
Used to create collections for nodes in a repository.

_parentPath::
Reference to parent node path.

_path::
The path is resolved from the node name and parent path.

_permissions_read::
The principals that have read access.

_permissions_create::
The principals that have create access.

_permissions_delete::
The principals that have delete access.

_permissions_modify::
The principals that have modify access.

_permissions_publish::
The principals that have publish access.

_permissions_readpermissions::
The principals that have access to read the node permissions.

_permissions_writepermissions::
The principals that have access to change the node permissions.

_state::
Used for keeping state of a node in a branch.

_timestamp::
The last time this node was modified

_versionKey::
For every modification of a node, a unique versionKey is generated


== Branches

Inspired by Git, XP repos supports a concept called branches.
Within a branch, nodes are organized hierarchically with paths that must be unique within the branch.
This means that the fully qualified location of a node consists of:

* repo
* branch
* path

Repositories have a default branch called ``master``.
Any number of branches could be added to facilitate your data model. Branches are typically ideal for facilitating long running transactions.

As an example, XP's CMS make use of two branches ``draft`` and ``master`` to support the editorial workflow, with previewing and bulk publishing of changes.

=== Pushing

XP provides advanced features such as diffing to see the changes between two branches.
Additionally, the API provides features for "pushing" changes from one branch to another.
The push operation automatically handles dependencies and and missing parent items to ensure the result is consistent.

From the CMS API, the push operation is known as "publish".

XP repos currently don't offer conflict resolution or merging functionality.
As such, conflict resolution must either be handled by the application itself, or the application must write data in a way that avoids creating conflicts.

=== Branch usage

Consider the 'Oslo' and 'Enonic' nodes from earlier sections:

image::nodes.png[]

There will be two *node-versions* in the repository stored in the blobstore:

image::node-versions.png[]

A node-version is a representation of a node's properties. A node-version has no knowledge of name, parent or other meta-data: just the properties of a node.
At the same time, the targeted branch (named 'draft' in this example) gets two entries:

image::branch_initial.png[]

The node-versions are now a part of a tree-structure, based on the node's name and parent.
If we *push* the content of branch 'draft' to the default branch 'master', we end up with something like this:

image::branch_push.png[]

At the moment, there are two branches pointing to the same node-versions. This means that a single node version can exist in several branches with different structures.
Now, consider that the 'oslo' - node is updated and stored to the 'draft'-branch, resulting in a new node-version with the same id and an updated pointer from the branch:

image::branch_diff.png[]

The two branches now point to different node-versions of the 'oslo' node.
Again, doing a push-operation from 'draft' to 'master' will result in both nodes pointing to the same node-versions:

image::branch_push_2.png[]


== Query Language
